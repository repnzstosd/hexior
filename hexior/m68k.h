#pragma once

//
#include <stdint.h>
#include <vector>

//
#include "memory.h"

enum Interrupt {
	USER_VECTOR,
	AUTO_VECTOR,
	SPURIOUS,
	UNINITIALIZED
};

enum Flags {
	ADD,
	ADDX,
	CMP,
	LOGICAL,
	SUB,
	SUBX,
	ZN
};

enum Size {
	BYTE = 0,
	WORD = 1,
	LONG = 2
};

struct RegisterState {
	union {
		uint16_t	SR;
		struct {
			uint8_t	CCR;
			uint8_t h;
		};
		struct {
			bool		carry				: 1;
			bool		overflow		: 1;
			bool		zero				: 1;
			bool		negative		: 1;
			bool		extend			: 1;
			bool		notused5		: 1;
			bool		notUsed6		: 1;
			bool		notUsed7		: 1;
			uint8_t	interrupt		: 3;
			bool		notUsed11		: 1;
			bool		notUsed12		: 1;
			bool		supervisor	: 1;
			bool		notUsed14		: 1;	// for 68000, 68010, CPU32 this is always zero, else it's trace0
			bool		trace				: 1;
		};
	};
	inline operator uint16_t() const { return SR; }
	inline uint16_t operator  = (uint16_t data) { return SR = data; }
	inline uint16_t operator |= (uint16_t data) { return SR |= data; }
	inline uint16_t operator ^= (uint16_t data) { return SR ^= data; }
	inline uint16_t operator &= (uint16_t data) { return SR &= data; }
	RegisterState() : SR(0) {}
};

struct Register32 {
	union {
		uint32_t d;
		struct { uint16_t w, noUseW; };
		struct { uint8_t l, noUseH, noUseLb, noUseHb; };
	};
	inline uint32_t operator  = (uint32_t data) { return d = data; }
	inline uint32_t operator -= (uint32_t data) { return d -= data; }
	inline uint32_t operator += (uint32_t data) { return d += data; }
	inline uint32_t operator |= (uint32_t data) { return d |= data; }
	inline operator uint32_t() const { return d; }
	Register32() : d(0) {}
};

class M68K {
	public:
		M68K(void);
		~M68K(void);

		void	initialize(std::vector<Memory::mem> *memoryList);

		void			power();	// hard reset, also reset exception
		void			reset();	// reset exception
		int				step();		// emulate next opcode

		void			setInterrupt(uint8_t level);	// generated by external device (level 0 - 7), 0 -> disable, 7 -> NMI
		void			setInterruptType(Interrupt type) { mInterrupt = type; }	// default is AUTO_VECTOR

		uint16_t	openBus() { return mIRC; }	// last read PC value	- prefetcher..

		uint8_t		readByte(uint32_t offset);
		uint16_t	readWord(uint32_t offset);
		uint32_t	readLong(uint32_t offset);
		void			writeByte(uint32_t offset, uint8_t data);
		void			writeWord(uint32_t offset, uint16_t data);
		void			writeLong(uint32_t offset, uint32_t data);

		void			branch(uint16_t instruction);
		uint32_t	readData(uint8_t sourceMode, uint8_t sourceRegister, uint8_t operationSize);
		uint32_t	writeData(uint8_t sourceMode, uint8_t sourceRegister, uint8_t operationSize, uint32_t res);

	private:
		uint32_t	getInterruptVector(uint8_t level);

		void			traceException();
		void			illegalException(uint8_t iType);
		void			interruptException(uint8_t level);
		void			executeAt(uint8_t vector);
		void			switchToSupervisor();
		void			switchToUser();
		bool			checkCondition(uint8_t conditionCode);
		void			setFlags(uint8_t type, uint8_t size, uint64_t result, uint32_t source, uint32_t dest);

		uint8_t		getBits(uint8_t size);
		uint32_t	getMSB(uint8_t size);
		uint32_t	getMask(uint8_t size);
		uint32_t	maskValue(uint32_t value, uint8_t size);

	public:
		//union {
		//	uint16_t	SR;
		//	uint8_t		CCR;
		//} mSR;

		//enum SRF {
		//	carry				= 1 << 0,
		//	overflow		= 1 << 1,
		//	zero				= 1 << 2,
		//	negative		= 1 << 3,
		//	extend			= 1 << 4,
		//	intMask0		= 1 << 8,
		//	intMask1		= 1 << 9,
		//	intMask2		= 1 << 10,
		//	supervisor	= 1 << 13,
		//	traceMode		= 1 << 15,
		//};

		RegisterState		mSR;
		Register32			mDataRegister[8];
		Register32			mAddressRegister[8];
		Interrupt				mInterrupt;

		uint16_t				mIRC;
		uint16_t				mIRD;
		uint16_t				mIR;

		uint32_t				mSSP;
		uint32_t				mUSP;
		uint32_t				mPC;				// only the lower 24bits are used on m68k.

	private:
		std::vector<Memory::mem>	*mMemory;
};

